#!/bin/bash

# This script assumes the following environment variables have been set:
# REPO_KEY: a base64 encoded private key used to access the core repository. Obtain with: base64 [privatekey] | tr -d '\n'
# REPO_ENV: the environment of the container, used to create the name of the tarball. i.e., load, dev, qa, prod
# REPO_HOST: the host of the repository. should include username, user@host style for ssh

# Globals
PROG_NAME=$(basename $0)
REPO_KEY_PATH=/tmp/.ssh/
REPO_KEY_FILE=${REPO_KEY_PATH}/repo_key
REPO_REMOTE_PATH=${REMOTE_REPO_PATH:-/var/lib/crepo/cores}
CORE_PATH=/var/solr/data

# Generic function definitions
function log() {
	echo "*** ${1} ***"
}

function solr_query() {
	curl -s "http://solr:8983/solr/admin/cores?$@"
}

function solr_create() {
	API_CREATE="action=CREATE&config=solrconfig.xml&schema=schema.xml"
	RESPONSE=$(solr_query "${API_CREATE}&name=${1}&instanceDir=${2}&dataDir=${2}/data")

	if [ ! "$(echo $RESPONSE | jq .responseHeader.status)" -eq 0 ]; then
		log "ERROR CREATING SOLR CORE: ${1}"
		echo $RESPONSE | jq
		exit -1
	fi
}

function solr_core_info() {
	VALUE=$(echo ${1} | jq -r ".status[ .status | keys[0] ].${2}")
	[ -z ${3+x} ] && KEY="$2" || KEY="$3"
	echo "$KEY: $VALUE"
}

function solr_status() {
	solr_query "action=STATUS&core=${1}"
}

function solr_info() {
	RESPONSE=$(solr_status "$1")
	solr_core_info "$RESPONSE" name
	solr_core_info "$RESPONSE" instanceDir
	solr_core_info "$RESPONSE" startTime
	solr_core_info "$RESPONSE" index.size size
}

function remotecmd() {
	ssh -i $REPO_KEY_FILE \
		-o "StrictHostKeyChecking No" \
		-o "UserKnownHostsFile $REPO_KEY_PATH/known_hosts" \
		$REPO_HOST "$@"
}

# sub_command function definitions
function sub_help() {
	cat <<-EOF
		Usage: $PROG_NAME push [corename]
			or $PROG_NAME pull [corename]
			or $PROG_NAME list
		Push or pull in Solr cores by using tar and ssh to archive and transfer

		Format for the remote name is: ENVIRONMENT_CORENAME_DATESTAMP.tar.gz (DATESTAMP is YYYY-MM-DD_HH.MM)
		NOTE: Acts on the core *name* not on the instanceDir.  Solr is queried to find the instanceDir
	EOF
}

function sub_push() {
	CORE_NAME=$1
	CORE_FULL_PATH="${CORE_PATH}/${CORE_NAME}"

	if [ "$CORE_NAME" == "" ]; then
		log "Core name is required!"
		sub_help
		exit -1
	fi

	# Find instanceDir for core
	SOLR_OUTPUT="$(solr_status ${CORE_NAME})"
	INSTANCE_OUTPUT="$(solr_core_info "$SOLR_OUTPUT" instanceDir)"
	INSTANCE_DIR=$(echo $INSTANCE_OUTPUT | awk '{print $2}')
	log "${INSTANCE_OUTPUT}"

	if [ "$INSTANCE_DIR" == "" ]; then
		log "core not found in solr!"
		exit -1
	fi
 
	if [ ! -d "$INSTANCE_DIR" ]; then
		log "${INSTANCE_DIR} doesn't exist!"
		sub_help
		exit -1
	fi

	DATESTAMP=$(date +"%F_%H.%M")
	REMOTE_NAME="${REMOTE_REPO_PATH}/${REPO_ENV}_${CORE_NAME}_${DATESTAMP}.tar.gz"
	log "pushing ${CORE_NAME} (${INSTANCE_DIR}) to ${REPO_HOST} as ${REMOTE_NAME}"
	tar -C ${INSTANCE_DIR} -czf - . | remotecmd "cat > $REMOTE_NAME"
}

function sub_list() {
	remotecmd "ls -ltr $REMOTE_REPO_PATH"
}

function sub_pull() {
	TAR_FILENAME=$1
	# CORE_REGEX removes ".tar.gz" suffix on file
	CORE_REGEX='s/^([a-z0-9]+_[a-z_]*_[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{2}.[0-9]{2}).*/\1/'
	LOCAL_CORE_NAME=$(echo $TAR_FILENAME | sed -E ${CORE_REGEX})
	DEST_DIR=${SOLR_HOME}/${LOCAL_CORE_NAME}

	log "pulling ${TAR_FILENAME} and expanding in ${DEST_DIR}"
	mkdir $DEST_DIR || exit -1 && \
	remotecmd "cat ${REMOTE_REPO_PATH}/${TAR_FILENAME}" | tar -C ${DEST_DIR} -xzf - .

	# move aside core.properties
	mv ${DEST_DIR}/core.properties ${DEST_DIR}/core.properties.crepo || true

	# issue create call to solr to load core
	solr_create "${LOCAL_CORE_NAME}" "${DEST_DIR}" && \
	log "core ${LOCAL_CORE_NAME} created: " && \
	solr_info "${LOCAL_CORE_NAME}"
}

# Create key dir/content if needed
[ ! -d "$REPO_KEY_PATH" ] && mkdir -p -m 700 "$REPO_KEY_PATH"
[ ! -s "$REPO_KEY_FILE" ] && echo "$REPO_KEY" | base64 -d > "$REPO_KEY_FILE"
chmod 600 "$REPO_KEY_FILE"

# Main routine
subcommand=$1

case $subcommand in
	"" | "-h" | "--help")
		sub_help
		;;
	*)
		shift
		sub_${subcommand} $@
		if [ $? = 127 ]; then
			echo "Error: '$subcommand' is not a known subcommand." >&2
			echo "       Run '$PROG_NAME --help' for a list of known subcommands." >&2
			exit 1
		fi
		;;
esac
